!function(t,i){"object"==typeof exports&&"object"==typeof module?module.exports=i():"function"==typeof define&&define.amd?define([],i):"object"==typeof exports?exports.RayCaster=i():t.RayCaster=i()}(self,(()=>(()=>{"use strict";var t={d:(i,e)=>{for(var s in e)t.o(e,s)&&!t.o(i,s)&&Object.defineProperty(i,s,{enumerable:!0,get:e[s]})},o:(t,i)=>Object.prototype.hasOwnProperty.call(t,i),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},i={};t.r(i),t.d(i,{createCamera:()=>c,createSkyBox:()=>w,createSprite:()=>u,createTextureMap:()=>m,createWorld:()=>y,initKeyboardControl:()=>M,initMouseControl:()=>O,initPointerLockControl:()=>g});const e=class{constructor(t,i,e,s,o=0,h=null){if(this.pos={x:i.x,x:i.y},this.ang=o,this.src=t,this.width=e,this.height=s,this.pInst=h,this.buffer=null,null!==this.pInst)this.buffer=this.pInst.createGraphics(this.width,this.height);else{if(!window.createGraphics)throw new Error("p5 is not found!");this.buffer=window.createGraphics(this.width,this.height)}this.animationFrames=Math.floor(this.src.width/this.width),this.rotationFrames=Math.floor(this.src.height/this.height),this.currentRotation=0,this.currentAnimation=0,this.rotationFrames>1&&(this.rotationDivision=2*Math.PI/this.rotationFrames,this.updateRotationFrame(Math.PI)),this.updateAnimationFrame(0)}nextAnimationFrame(){this.currentAnimation++,this.currentAnimation=this.currentAnimation%this.animationFrames,this.drawBuffer()}updateAnimationFrame(t){this.currentAnimation!==t&&(this.currentAnimation=t,this.drawBuffer())}updateRotationFrame(t){let i,e;if(1===this.rotationFrames)e=0;else{for(i=t-this.ang+this.rotationDivision/2;i<0;)i+=2*Math.PI;for(;i>2*Math.PI;)i-=2*Math.PI;e=Math.floor(i/this.rotationDivision)}this.currentRotation!==e&&(this.currentRotation=e,this.drawBuffer())}move(t){if(!this.world)return;let i=Math.floor(this.pos.x+t.x)+Math.floor(this.pos.y)*this.world.width,e=Math.floor(this.pos.x)+Math.floor(this.pos.y+t.y)*this.world.width;this.world.map[i]!==this.world.table.MAP_FLOOR&&this.world.doorStates[i]!==this.world.table.DOOR_OPEN||Math.floor(this.pos.x+t.x)>-1&&Math.floor(this.pos.x+t.x)<this.world.width&&(this.pos.x+=t.x),this.world.map[e]!==this.world.table.MAP_FLOOR&&this.world.doorStates[e]!==this.world.table.DOOR_OPEN||Math.floor(this.pos.y+t.y)>-1&&Math.floor(this.pos.y+t.y)<this.world.height&&(this.pos.x+=t.y)}rotate(t){this.ang+=t}drawBuffer(){this.buffer.clear(),this.buffer.image(this.src,0,0,this.width,this.height,this.currentRotation*this.width,this.currentAnimation*this.height,this.width,this.height)}destroy(){this.drawBuffer.remove()}};class s{static defaultTypeTable={MAP_FLOOR:0,MAP_WALL:1,MAP_WALL_SHADOW:2,MAP_DOOR:3,MAP_DOOR_FRAME:4,MAP_PUSH_WALL:5,MAP_CIRCULAR_COLUMN:6,MAP_DIA_WALL_TR_BL:7,MAP_DIA_WALL_TL_BR:8,MAP_TRANSPARENT_WALL:9,DOOR_CLOSED:0,DOOR_OPENING:1,DOOR_OPEN:2,DOOR_CLOSING:3};static defaultSkyBox={sky:"black",ground:"grey",front:null,middle:null,back:null};constructor(t=24,i=24,e=null,o=null,h=s.defaultSkyBox,r=s.defaultTypeTable,a=null){this.width=t,this.height=i,this.map=new Array(this.width*this.height).fill(0),this.table=r,this.skyBox=h,this.sprites=[],this.cameras=[],this.textureMap=o,this.loadMap(e,a)}loadMap(t,i){if(t&&t.length)if("string"==typeof t)t.split(",").forEach(((t,i)=>{this.map[i]=parseInt(t),this.map[i]%10===this.table.MAP_WALL_SHADOW&&(console.warn(`[p5RayCaster]: MAP_WALL_SHADOW ${this.map[i]} should not be used in the map, changed to MAP_WALL ${Math.floor(this.map[i]/10)+this.table.MAP_WALL}`),this.map[i]=Math.floor(this.map[i]/10)+this.table.MAP_WALL)}));else if("number"==typeof t[0])t.forEach(((t,i)=>{this.map[i]=t,this.map[i]%10===this.table.MAP_WALL_SHADOW&&(console.warn(`[p5RayCaster]: MAP_WALL_SHADOW ${this.map[i]} should not be used in the map, changed to MAP_WALL ${Math.floor(this.map[i]/10)+this.table.MAP_WALL}`),this.map[i]=Math.floor(this.map[i]/10)+this.table.MAP_WALL)}));else if("number"==typeof t[0][0])for(let i=0;i<t.length;i++)for(let e=0;e<t[i].length;e++){let s=e+i*this.width;this.map[s]=t[i][e],this.map[s]%10===this.table.MAP_WALL_SHADOW&&(console.warn(`[p5RayCaster]: MAP_WALL_SHADOW ${this.map[s]} should not be used in the map, changed to MAP_WALL ${Math.floor(this.map[s]/10)+this.table.MAP_WALL}`),this.map[s]=Math.floor(this.map[s]/10)+this.table.MAP_WALL)}this.doorOffsets=new Array(this.width*this.height).fill(0),this.doorStates=new Array(this.width*this.height).fill(0),this.doorSpeed=i&&i.doorSpeed?i.doorSpeed:.1,this.doorAutoClose=!(!i||!i.doorAutoClose)&&i.doorAutoClose,this.doorClosingTime=i&&i.doorClosingTime?i.doorClosingTime:0}loadTextureMap(t){this.textureMap=t}addSprite(t){this.sprites.push(t),t.world=this,this.cameras.forEach((t=>{t.updateSpritesBuffers()}))}removeSprite(t){if(t instanceof e){delete t.world;let i=this.sprites.indexOf(t);if(-1===i)return void console.warn("invalid remove: sprite is not in the world");t=i}delete this.sprites[t].world,this.sprites.splice(t,1),this.cameras.forEach((t=>{t.updateSpritesBuffers()}))}update(t=30){const i=1/t;for(let t=0;t<this.map.length;t++){const e=this.map[t];e===this.table.MAP_DOOR?this.doorStates[t]===this.table.DOOR_OPENING?(this.doorOffsets[t]+=i*this.doorSpeed,this.doorOffsets[t]>1&&(this.doorOffsets[t]=1,this.doorStates[t]=this.table.DOOR_OPEN,this.doorAutoClose&&setTimeout((t=>{this.doorStates[t]=this.table.DOOR_CLOSING}),this.doorClosingTime,t))):this.doorStates[t]===this.table.DOOR_CLOSING&&(this.doorOffsets[t]-=i*this.doorSpeed,this.doorOffsets[t]<0&&(this.doorOffsets[t]=0,this.doorStates[t]=this.table.DOOR_CLOSED)):e===this.table.MAP_PUSH_WALL&&this.doorStates[t]===this.table.DOOR_OPENING&&(this.doorOffsets[t]+=i*this.doorSpeed,this.doorOffsets[t]>1&&(this.doorOffsets[t]=1,this.doorStates[t]=this.table.DOOR_OPEN))}}openDoor(t,i){let e=1===arguments.length?t:t+i*this.width;this.map[e]!==this.table.MAP_DOOR&&this.map[e]!==this.table.MAP_PUSH_WALL||this.doorStates[e]===this.table.DOOR_CLOSED&&(this.doorStates[e]=this.table.DOOR_OPENING)}closeDoor(t,i){let e=1===arguments.length?t:t+i*this.width;this.map[e]===this.table.MAP_DOOR&&this.doorStates[e]===this.table.DOOR_OPEN&&(this.doorStates[e]=this.table.DOOR_CLOSING)}moveDoor(t,i){let e=1===arguments.length?t:t+i*this.width;this.map[e]===this.table.MAP_DOOR&&(this.doorStates[e]===this.table.DOOR_OPEN?this.doorStates[e]=this.table.DOOR_CLOSING:this.doorStates[e]===this.table.DOOR_CLOSED&&(this.doorStates[e]=this.table.DOOR_OPENING)),this.map[e]===this.table.MAP_PUSH_WALL&&this.doorStates[e]===this.table.DOOR_CLOSED&&(this.doorStates[e]=this.table.DOOR_OPENING)}}const o=s,h=class{constructor(t,i,e,s,o,h){this.mapX=i,this.mapY=e,this.camera=t,this.side=s,this.screenX=[o],this.tex=h}getRayDir(t,i,e){return e||(e=this.camera.cameraXCoords),1===i?this.camera.dir.y+this.camera.plane.y*e[t]:this.camera.dir.x+this.camera.plane.x*e[t]}getPerpDist(t){let i=1,e=this.getRayDir(t,this.side);return e<0&&(i=-1),1===this.side?(this.mapY-this.camera.pos.y+.5*i+(1-i)/2)/e:(this.mapX-this.camera.pos.x+.5*i+(1-i)/2)/e}display(t,i){const e=t._isMainCanvas?t._pInst:t,s=this.camera.world.textureMap.get(this.tex);e.push(),e.drawingContext.globalAlpha=.5;for(let o=this.screenX[0];o<this.screenX[0]+this.screenX.length;o++){let h,r=this.getPerpDist(o),a=Math.round(t.height/r),l=(.5+i)*t.height-a/2;if(0===this.side?h=this.camera.pos.y+r*this.getRayDir(o,1):1===this.side&&(h=this.camera.pos.x+r*this.getRayDir(o,0)),h-=Math.floor(h),"string"==typeof s)e.stroke(s),e.line(o,l,o,l+a);else{let t=Math.floor(h*s.width);e.image(s,o,l,1,a,t,0,1,s.height)}}e.pop()}},r=class{static lineIntersection(t,i,e,s,o=!1){let h=i.y-t.y,r=t.x-i.x,a=h*t.x+r*t.y,l=s.y-e.y,n=e.x-s.x,d=l*e.x+n*e.y,p=h*n-l*r;if(0===p)return null;let f=(n*a-r*d)/p,m=(h*d-l*a)/p;if(o){let e=(f-t.x)/(i.x-t.x),s=(m-t.y)/(i.y-t.y);return e>=0&&e<=1||s>=0&&s<=1?{x:f,y:m}:null}return{x:f,y:m}}static lineCircleIntersection(t,i,e,s,o=!1){let h,r,a,l,n={x:0,y:0};if(n.x=i.x-t.x,n.y=i.y-t.y,h=n.x*n.x+n.y*n.y,r=2*(n.x*(t.x-e.x)+n.y*(t.y-e.y)),a=e.x*e.x+e.y*e.y,a+=t.x*t.x+t.y*t.y,a-=2*(e.x*t.x+e.y*t.y),a-=s*s,l=r*r-4*h*a,l<0)return null;if(o)return{b:(-r-Math.sqrt(l))/(2*h)};let d=(-r+sqrt(l))/(2*h),p=(-r-sqrt(l))/(2*h);return[{x:t.x+d*(i.x-t.x),y:t.y+d*(i.y-t.y)},{x:t.x+p*(i.x-t.x),y:t.y+p*(i.y-t.y)}]}static rotateVector(t,i){return{x:t.x*Math.cos(i)-t.y*Math.sin(i),y:t.x*Math.sin(i)+t.y*Math.cos(i)}}static combineSort(t,i,e){let s=e,o=!1;for(;s>1||o;){s=Math.floor(10*s/13),9!=s&&10!=s||(s=11),s<1&&(s=1),o=!1;for(let h=0;h<e-s;h++){let e=h+s;i[h]<i[e]&&([i[h],i[e]]=[i[e],i[h]],[t[h],t[e]]=[t[e],t[h]],o=!0)}}}static normalize(t){let i=t.x*t.x+t.y*t.y;return 1===i?{x:t.x,y:t.y}:{x:t.x/Math.sqrt(i),y:t.y/Math.sqrt(i)}}};class a{static defaultMiniMapOptions={border:{stroke:"white",strokeWeight:3},background:{fill:"grey"},sprite:{fill:"purple",stroke:void 0,strokeWeight:0,dia:.5},camera:{fill:"yellow",stroke:void 0,strokeWeight:0,dia:.5},fov:{stroke:"black",strokeWeight:1},blocks:new Map([[0,{}],[1,{fill:"red"}],[3,{fill:"blue"}],[4,{fill:"blue"}],[5,{fill:"red",stroke:"blue",strokeWeight:1}],[6,{fill:"cyan"}],[7,{stroke:"red",strokeWeight:3}],[8,{stroke:"red",strokeWeight:3}],[9,{fill:"rgba(255,0,0,0.25)"}]]),MAP_FLOOR:{fill:void 0,stroke:void 0,strokeWeight:0},MAP_WALL:{fill:"red",stroke:void 0,strokeWeight:0},MAP_DOOR:{fill:"blue",stroke:void 0,strokeWeight:0},MAP_DOOR_FRAME:{fill:"black",stroke:"blue",strokeWeight:2},MAP_PUSH_WALL:{fill:"red",stroke:"blue",strokeWeight:1},MAP_CIRCULAR_COLUMN:{fill:"cyan",stroke:void 0,strokeWeight:0},MAP_DIA_WALL_TR_BL:{fill:void 0,stroke:"red",strokeWeight:3},MAP_DIA_WALL_TL_BR:{fill:void 0,stroke:"red",strokeWeight:3},MAP_TRANSPARENT_WALL:{fill:"rgba(255,0,0,0.25)",stroke:void 0,strokeWeight:0}};constructor(t,i,e,s=null,o=null){if(this.pos={x:t.x,y:t.y},this.dir=r.normalize(i),this.tilting=0,this.tiltingRange=[-Math.PI/4,Math.PI/4],this.plane=r.rotateVector(this.dir,-Math.PI/2),this.plane.x=this.plane.x*e,this.plane.y=this.plane.y*e,this.attachToWorld(s),this.canvas=o,null!==this.canvas){this.cameraXCoords=[];for(let t=0;t<this.canvas.width;t++)this.cameraXCoords.push(2*t/this.canvas.width-1)}this.zBuffer=o?new Array(o.width):[],this.spritesOrderBuffer=[],this.spritesDistanceBuffer=[],this.spritesUpdateGap=4,null!==s&&this.updateSpritesBuffers(),this.miniMapOptions=a.defaultMiniMapOptions}attachToWorld(t){this.world=t,null!==t&&t.cameras.push(this)}removeFromWorld(){this.world.camera.splice(this.world.cameras.indexOf(this),1),this.world=null}updateSpritesBuffers(){if(null===this.world||this.world.sprites.length<1)return;const t=this.world.sprites;for(let i=0;i<t.length;i++)this.spritesOrderBuffer[i]=i,this.spritesDistanceBuffer[i]=(this.pos.x-t[i].pos.x)*(this.pos.x-t[i].pos.x)+(this.pos.y-t[i].pos.y)*(this.pos.y-t[i].pos.y);r.combineSort(this.spritesOrderBuffer,this.spritesDistanceBuffer,t.length)}setMiniMapRenderOptions(t){this.miniMapOptions=t}teleportTo(t,i,e=null){this.pos.x=t.x,this.pos.y=t.y,i&&(this.dir.x=i.x,this.dir.y=i.y,this.plane=r.rotateVector(this.dir,-Math.PI/2),this.plane.x=this.plane.x*fov,this.plane.y=this.plane.y*fov),e&&null!==e&&(this.removeFromWorld(),this.attachToWorld(e))}move(t){if(null===this.world)throw new Error("world should be set before manipulating camera");let i=Math.floor(this.pos.x+t.x)+Math.floor(this.pos.y)*this.world.width,e=Math.floor(this.pos.x)+Math.floor(this.pos.y+t.y)*this.world.width;this.world.map[i]!==this.world.table.MAP_FLOOR&&this.world.doorStates[i]!==this.world.table.DOOR_OPEN||Math.floor(this.pos.x+t.x)>-1&&Math.floor(this.pos.x+t.x)<this.world.width&&(this.pos.x+=t.x),this.world.map[e]!==this.world.table.MAP_FLOOR&&this.world.doorStates[e]!==this.world.table.DOOR_OPEN||Math.floor(this.pos.y+t.y)>-1&&Math.floor(this.pos.y+t.y)<this.world.height&&(this.pos.y+=t.y)}rotate(t){this.dir=r.rotateVector(this.dir,t),this.plane=r.rotateVector(this.plane,t)}tilt(t){this.tilting+=t,this.tilting>this.tiltingRange[1]&&(this.tilting=this.tiltingRange[1]),this.tilting<this.tiltingRange[0]&&(this.tilting=this.tiltingRange[0])}updateTiltingRange(t,i){this.tiltingRange[0]=t,this.tiltingRange[1]=i}openDoor(){let t=Math.floor(this.pos.x+this.dir.x),i=Math.floor(this.pos.y+this.dir.y),e=Math.floor(this.pos.x+2*this.dir.x),s=Math.floor(this.pos.y+2*this.dir.y),o=t+i*this.world.width,h=e+s*this.world.width;this.world.openDoor(o),this.world.openDoor(h);let r=Math.floor(this.pos.x)+Math.floor(this.pos.y)*this.world.width;this.world.map[r]===this.world.table.MAP_DOOR&&(this.world.doorStates[r]=this.world.table.DOOR_OPENING)}closeDoor(){let t=Math.floor(this.pos.x+this.dir.x),i=Math.floor(this.pos.y+this.dir.y),e=Math.floor(this.pos.x+2*this.dir.x),s=Math.floor(this.pos.y+2*this.dir.y),o=t+i*this.world.width,h=e+s*this.world.width;this.world.closeDoor(o),this.world.closeDoor(h);let r=Math.floor(this.pos.x)+Math.floor(this.pos.y)*this.world.width;this.world.map[r]===this.world.table.MAP_DOOR&&(this.world.doorStates[r]=this.world.table.DOOR_OPENING)}moveDoor(){let t=Math.floor(this.pos.x+this.dir.x),i=Math.floor(this.pos.y+this.dir.y),e=Math.floor(this.pos.x+2*this.dir.x),s=Math.floor(this.pos.y+2*this.dir.y),o=t+i*this.world.width,h=e+s*this.world.width;this.world.moveDoor(o),this.world.moveDoor(h);let r=Math.floor(this.pos.x)+Math.floor(this.pos.y)*this.world.width;this.world.map[r]===this.world.table.MAP_DOOR&&(this.world.doorStates[r]=this.world.table.DOOR_OPENING)}renderMiniMap(t,i,e,s,o,h=this.canvas){const r=h._isMainCanvas?h._pInst:h;let a=Math.floor(this.pos.x),l=Math.floor(this.pos.y),n={x:s/(2*t.x+1),y:o/(2*t.y+1)};r.push(),r.fill(this.miniMapOptions.background.fill),r.rect(i,e,s,o);for(let o=0;o<2*t.x+1;o++)for(let h=0;h<2*t.y+1;h++){let d=a-t.x+o,p=l-t.y+h;if(d<0||d>this.world.width-1||p<0||p>this.world.height-1)continue;let f=d+p*this.world.width,m=i+s-(o+1)*n.x,w=e+h*n.y;if(this.miniMapOptions.blocks.has(this.world.map[f])){let t=this.miniMapOptions.blocks.get(this.world.map[f]);if(t.icon)r.image(t.icon,m,w,n.x,n.y);else switch(t.fill?r.fill(t.fill):r.noFill(),t.stroke?(r.stroke(t.stroke),t.strokeWeight&&r.strokeWeight(t.strokeWeight)):r.noStroke(),this.world.map[f]%10){default:r.rect(m,w,n.x,n.y);break;case this.world.table.MAP_DIA_WALL_TR_BL:r.line(m,w,m+n.x,w+n.y);break;case this.world.table.MAP_DIA_WALL_TL_BR:r.line(m+n.x,w,m,w+n.y);break;case this.world.table.MAP_CIRCULAR_COLUMN:r.ellipse(m+n.x/2,w+n.y/2,n.x,n.y)}}else{let t;switch(this.world.map[f]%10){case this.world.table.MAP_FLOOR:t=this.miniMapOptions.MAP_FLOOR;break;case this.world.table.MAP_WALL:case this.world.table.MAP_WALL_SHADOW:t=this.miniMapOptions.MAP_WALL;break;case this.world.table.MAP_DOOR:t=this.miniMapOptions.MAP_DOOR;break;case this.world.table.MAP_DOOR_FRAME:t=this.miniMapOptions.MAP_DOOR_FRAME;break;case this.world.table.MAP_PUSH_WALL:t=this.miniMapOptions.MAP_PUSH_WALL;break;case this.world.table.MAP_CIRCULAR_COLUMN:t=this.miniMapOptions.MAP_CIRCULAR_COLUMN;break;case this.world.table.MAP_DIA_WALL_TR_BL:t=this.miniMapOptions.MAP_DIA_WALL_TR_BL;break;case this.world.table.MAP_DIA_WALL_TL_BR:t=this.miniMapOptions.MAP_DIA_WALL_TL_BR;break;case this.world.table.MAP_TRANSPARENT_WALL:t=this.miniMapOptions.MAP_TRANSPARENT_WALL}if(t.icon)r.image(t.icon,m,w,n.x,n.y);else switch(t.fill?r.fill(t.fill):r.noFill(),t.stroke?(r.stroke(t.stroke),t.strokeWeight&&r.strokeWeight(t.strokeWeight)):r.noStroke(),this.world.map[f]%10){default:r.rect(m,w,n.x,n.y);break;case this.world.table.MAP_DIA_WALL_TR_BL:r.line(m,w,m+n.x,w+n.y);break;case this.world.table.MAP_DIA_WALL_TL_BR:r.line(m+n.x,w,m,w+n.y);break;case this.world.table.MAP_CIRCULAR_COLUMN:r.ellipse(m+n.x/2,w+n.y/2,n.x,n.y)}}}let d=i+s-(this.pos.x-Math.floor(this.pos.x)+t.x)*n.x,p=e+(this.pos.y-Math.floor(this.pos.y)+t.y)*n.y;this.miniMapOptions.camera.fill?r.fill(this.miniMapOptions.camera.fill):r.noFill(),this.miniMapOptions.camera.stroke&&(r.stroke(this.miniMapOptions.camera.stroke),this.miniMapOptions.camera.strokeWeight&&r.strokeWeight(this.miniMapOptions.camera.strokeWeight)),r.ellipse(d,p,this.miniMapOptions.camera.dia*n.x,this.miniMapOptions.camera.dia*n.y),this.miniMapOptions.fov.stroke&&(r.stroke(this.miniMapOptions.fov.stroke),this.miniMapOptions.fov.strokeWeight&&r.strokeWeight(this.miniMapOptions.fov.strokeWeight),r.line(d,p,d-(this.dir.x+this.plane.x)*n.x,p+(this.dir.y+this.plane.y)*n.y),r.line(d,p,d-(this.dir.x-this.plane.x)*n.x,p+(this.dir.y-this.plane.y)*n.y)),this.miniMapOptions.sprite.fill?r.fill(this.miniMapOptions.sprite.fill):r.noFill(),this.miniMapOptions.sprite.stroke&&(r.stroke(this.miniMapOptions.sprite.stroke),this.miniMapOptions.sprite.strokeWeight&&r.strokeWeight(this.miniMapOptions.sprite.strokeWeight)),this.world.sprites.forEach((o=>{if(o.pos.x>a-t.x&&o.pos.x<a+t.x&&o.pos.y>l-t.y&&o.pos.y<l+t.y){let h=i+s-(o.pos.x-(a-t.x))*n.x,d=e+(o.pos.y-(l-t.y))*n.y;r.ellipse(h,d,this.miniMapOptions.sprite.dia*n.x,this.miniMapOptions.sprite.dia*n.y)}})),r.pop()}renderSkyBox(t=this.canvas){const i=.5+Math.tan(this.tilting),e=1-i,s=t._isMainCanvas?t._pInst:t,o=this.world.skyBox;if(s.push(),"string"==typeof o.sky)s.fill(o.sky),s.noStroke(),s.rect(0,0,s.width,s.height*i);else{let t=o.sky;s.image(t,0,0,s.width,s.height*i,0,t.height-s.height*i,s.width,s.height*i)}if(o.back||o.front||o.middle){let t=this.world.width/2-this.pos.x,e=this.world.height/2-this.pos.y,h={x:this.world.width/2*this.dir.x+t,y:this.world.height/2*this.dir.y+e},r={x:this.pos.x+h.x,y:this.pos.y+h.y},a=Math.sqrt((r.x-this.pos.x)*(r.x-this.pos.x)+(r.y-this.pos.y)*(r.y-this.pos.y)),l=a+a,n=(Math.atan2(this.dir.y,this.dir.x)+Math.PI)/Math.PI,d=Math.floor(n*s.width),p=Math.floor(d/1.5),f=Math.floor(d/2),m=s.height*i;if(o.back){let t=s.width/2,i=m/2;s.image(o.back,f,i,t,i,0,m-o.back.height,o.back.width,o.back.height),s.image(o.back,f-t,i,t,i,0,m-o.back.height,o.back.width,o.back.height),n>1&&s.image(o.back,f-s.width,i,t,i,0,m-o.back.height,o.back.width,o.back.height),n<1&&s.image(o.background,f+t,i,t,i,0,m-o.background.height,o.background.width,o.background.height)}if(o.middle){let t=s.width/1.5,i=m/1.5,e=m/3-this.world.width+a;s.image(o.middle,p-t,e,t,i,0,m-o.middle.height,o.middle.width,o.middle.height),n<1.5&&s.image(o.middle,p,e,t,i,0,m-o.middle.height,o.middle.width,o.middle.height),n<.5&&s.image(o.middle,p+t,e,t,i,0,m-o.middle.height,o.middle.width,o.middle.height),n>1&&s.image(o.middle,p-2*t,e,t,i,0,m-o.middle.height,o.middle.width,o.middle.height)}o.front&&(s.image(o.front,d-s.width,2*-this.world.width+l,s.width,m,0,m-o.front.height,o.front.width,o.front.height),n<1&&s.image(o.front,d,2*-this.world.width+l,s.width,m,0,m-o.front.height,o.front.width,o.front.height),n>1&&s.image(o.front,d-2*s.width,2*-this.world.width+l,s.width,m,0,m-o.front.height,o.front.width,o.front.height))}if("string"==typeof o.ground)s.fill(o.ground),s.noStroke(),s.rect(0,s.height*i,s.width,s.height*e);else{let t=o.sky;s.image(t,0,s.height*i,s.width,s.height*e,0,t.height-s.height*e,s.width,s.height*e)}s.pop()}renderRayCasting(t=this.canvas,i=!1){const e=t._isMainCanvas?t._pInst:t,s=Math.tan(this.tilting);e.push();let o=[],a=[];if(t===this.canvas)o=this.cameraXCoords;else for(let i=0;i<t.width;i++)o.push(2*i/t.width-1);for(let i=0;i<t.width;i++){let y,u,c,M,O,g,x,A,_={x:this.dir.x+this.plane.x*o[i],y:this.dir.y+this.plane.y*o[i]},b=Math.floor(this.pos.x),k=Math.floor(this.pos.y),L=Math.abs(1/_.x),P=Math.abs(1/_.y),D=0,R={x:0,y:0};for(_.x<0?(M=-1,y=(this.pos.x-b)*L):(M=1,y=(b+1-this.pos.x)*L),_.y<0?(O=-1,u=(this.pos.y-k)*P):(O=1,u=(k+1-this.pos.y)*P);0===D&&(y<u?(y+=L,b+=M,g=0):(u+=P,k+=O,g=1),!(b<0||b>this.world.width||k<0||k>this.world.height));){let t=b+k*this.world.width;var l;if(x=this.world.map[t],x!==this.world.table.MAP_FLOOR)switch(x%10){case this.world.table.MAP_DOOR:this.world.doorStates[t]!==this.world.table.DOOR_OPEN&&(D=1,1==g?(R.y=.5*O,c=(k-this.pos.y+R.y+(1-O)/2)/_.y,l=this.pos.x+c*_.x,l-=Math.floor(l),u-P/2<y?1-l<=this.world.doorOffsets[t]&&(D=0,R.y=0):(b+=M,t=b+k*this.world.width,g=0,x=Math.floor(x/10)+this.world.table.MAP_DOOR_FRAME,R.y=0)):(R.x=.5*M,c=(b-this.pos.x+R.x+(1-M)/2)/_.x,l=this.pos.y+c*_.y,l-=Math.floor(l),y-L/2<u?1-l<this.world.doorStates[t]&&(D=0,R.x=0):(k+=O,t=b+k*this.world.width,g=1,x=Math.floor(x/10)+this.world.table.MAP_DOOR_FRAME,R=0)));break;case this.world.table.MAP_PUSH_WALL:this.world.doorStates[t]!==this.world.table.DOOR_OPEN&&(1==g&&u-P*(1-this.world.doorOffsets[t])<y?(D=1,R.y=this.world.doorOffsets[t]*O):0==g&&y-L*(1-this.world.doorOffsets[t])<u&&(D=1,R.x=this.world.doorOffsets[t]*M));break;case this.world.table.MAP_CIRCULAR_COLUMN:let e=r.lineCircleIntersection({x:this.pos.x,y:this.pos.y},{x:this.pos.x+_.x,y:this.pos.y+_.y},{x:b+.5,y:k+.5},.5,!0);if(e){D=1,g=3;let t={x:this.pos.x+_.x*e.b,y:this.pos.y+_.y*e.b};c=(t.x-this.pos.x+t.y-this.pos.y)/2/((_.x+_.y)/2),l=Math.atan2(k+.5-t.y,b+.5-t.x)/(2*Math.PI),l+=l}break;case this.world.table.MAP_DIA_WALL_TR_BL:var n=b,d=k+1,p=b+1,f=k,m=r.lineIntersection({x:this.pos.x,y:this.pos.y},{x:this.pos.x+_.x,y:this.pos.y+_.y},{x:n,y:d},{x:p,y:f},!1);m&&m.x>=b&&m.x<=b+1&&m.y>=k&&m.y<=k+1&&((1==g&&O<0||0==g&&M<0)&&(A=1),D=1,g=2,c=(m.x-this.pos.x+m.y-this.pos.y)/2/((_.x+_.y)/2));break;case this.world.table.MAP_DIA_WALL_TL_BR:n=b,d=k,p=b+1,f=k+1,(m=r.lineIntersection({x:this.pos.x,y:this.pos.y},{x:this.pos.x+_.x,y:this.pos.y+_.y},{x:n,y:d},{x:p,y:f},!1))&&m.x>=b&&m.x<=b+1&&m.y>=k&&m.y<=k+1&&((1==g&&O>0||0==g&&M<0)&&(A=1),D=1,g=2,c=(m.x-this.pos.x+m.y-this.pos.y)/2/((_.x+_.y)/2));break;case this.world.table.MAP_TRANSPARENT_WALL:if(1==g){if(u-P/2<y){let t=!1;for(let e=0;e<a.length;e++)if(a[e].mapX===b&&a[e].mapY===k){a[e].screenX.push(i),t=!0;break}t||a.push(new h(this,b,k,g,i,x))}}else if(y-L/2<u){let t=!1;for(let e=0;e<a.length;e++)if(a[e].mapX===b&&a[e].mapY===k){a[e].screenX.push(i),t=!0;break}t||a.push(new h(this,b,k,g,i,x))}break;case this.world.table.MAP_WALL_SHADOW:x=1===g&&this.world.map[b+(k-O)*this.world.width]===this.world.table.MAP_DOOR?Math.floor(this.world.map[b+(k-O)*this.world.width]/10)+this.world.table.MAP_DOOR_FRAME:0===g&&this.world.map[b-M+k*this.world.width]===this.world.table.MAP_DOOR?Math.floor(this.world.map[b-M+k*this.world.width]/10)+this.world.table.MAP_DOOR_FRAME:10*Math.floor(x/10)+this.world.table.MAP_WALL,D=1;break;default:1===g&&this.world.map[b+(k-O)*this.world.width]===this.world.table.MAP_DOOR?x=Math.floor(this.world.map[b+(k-O)*this.world.width]/10)+this.world.table.MAP_DOOR_FRAME:0===g&&this.world.map[b-M+k*this.world.width]===this.world.table.MAP_DOOR&&(x=Math.floor(this.world.map[b-M+k*this.world.width]/10)+this.world.table.MAP_DOOR_FRAME),D=1}}if(0===D);else{0===g?c=(b-this.pos.x+R.x+(1-M)/2)/_.x:1===g&&(c=(k-this.pos.y+R.y+(1-O)/2)/_.y);let o=Math.round(t.height/c),h=(.5+s)*t.height-o/2,r=h+o;0===g?l=this.pos.y+c*_.y:1!==g&&2!==g||(l=this.pos.x+c*_.x),l-=Math.floor(l),x%10===this.world.table.MAP_DOOR&&(l+=this.world.doorOffsets[b+b*this.world.width]);let a=this.world.textureMap.get(x);if("string"==typeof a)e.stroke(a),e.line(i,h,i,h+o);else{let t=Math.floor(l*a.width);(0===g&&_.x>0||1===g&&_.y<0)&&(t=a.width-t-1),e.image(a,i,h,1,o,t,0,1,a.height)}if(1===g&&x%10!==this.world.MAP_DOOR){let t=this.world.textureMap.get(10*Math.floor(x/10)+this.world.table.MAP_WALL_SHADOW);if(t)if("string"==typeof t)e.stroke(t),e.line(i,h,i,r);else{let s=Math.floor(l*t.width);_.y<0&&(s=t.width-s-1),e.image(t,i,h,1,o,s,0,1,t.height)}else e.stroke("rgba(0,0,0,0.5)"),e.line(i,h,i,r)}else if(2===g){let t=this.world.textureMap.get(10*Math.floor(x/10)+this.world.table.MAP_WALL_SHADOW);if(t){if(e.push(),w=0===A?.6*l:.6*(1-l),e.drawingContext.globalAlpha=w,"string"==typeof t)e.stroke(t),e.line(i,h,i,r);else{let s=Math.floor(l*t.width);e.image(t,i,h,1,o,s,0,1,t.height)}e.pop()}else{if(0===A)var w=.6*l;else w=.6*(1-l);e.stroke(`rgba(0,0,0,${w})`),e.line(i,h,i,r)}}this.zBuffer[i]=c}}let y=-1;if(a.length>0&&(y=a.length-1),!i){1!==e.frameCount&&e.frameCount%this.spritesUpdateGap!=0||this.updateSpritesBuffers();for(let i=0;i<this.world.sprites.length;i++){let o=this.world.sprites[this.spritesOrderBuffer[i]].pos.x-this.pos.x,h=this.world.sprites[this.spritesOrderBuffer[i]].pos.y-this.pos.y,r=1/(this.plane.x*this.dir.y-this.dir.x*this.plane.y),l=r*(this.dir.y*o-this.dir.x*h),n=r*(this.plane.x*h-this.plane.y*o);if(n>0){for(;y>=0;y--){let e=(this.pos.x-a[y].mapX)*(this.pos.x-a[y].mapX)+(this.pos.y-a[y].mapY)*(this.pos.y-a[y].mapY);if(!(this.spritesDistanceBuffer[i]<e))break;a[y].display(t,s)}let r=Math.abs(Math.floor(t.height/n)),d=(.5+s)*t.height-r/2,p=Math.floor(t.width/2)*(1+l/n),f=Math.abs(Math.floor(t.height/n)),m=Math.floor(p-f/2),w=m+f,u=m,c=w;m<-f&&(m=-f),w>t.width+f&&(w=t.width+f);for(let t=m;t<w;t++)if(n>this.zBuffer[t]){if(!(t-u<=1)){c=t;break}u=t}if(u!==c&&u<t.width&&c>0){let t=this.world.sprites[this.spritesOrderBuffer[i]].width/f,s=Math.floor((u-m)*t);s<0&&(s=0);let a=Math.floor((c-u)*t)+1;a>this.world.sprites[this.spritesOrderBuffer[i]].width&&(a=this.world.sprites[this.spritesOrderBuffer[i]].width);let l=c-u;l<0&&(l=0);let n=Math.atan2(h,o);this.world.sprites[this.spritesOrderBuffer[i]].updateRotation(n),e.push(),e.drawingContext.imageSmoothingEnabled=!1,e.image(this.world.sprites[this.spritesOrderBuffer[i]].buffer,u,d,l,r,s,0,a,this.world.sprites[this.spritesOrderBuffer[i]].height),e.pop()}}}}for(;y>=0;y--)a[y].display(t,s);a.length=0,e.pop()}renderFrame(t=this.canvas){this.renderSkyBox(t),this.renderRayCasting(t,!1)}}const l=a;class n{static defaultKeyMap={forward:{keys:["w"]},backward:{keys:["s"]},goLeft:{keys:["a"]},goRight:{keys:["d"]},turnLeft:{keys:["q"]},turnRight:{keys:["e"]},tiltUp:{keys:["z"]},tiltDown:{keys:["x"]},moveDoor:{keys:[" "]}};constructor(t=n.defaultKeyMap){this.keyMap=t;for(const i in this.keyMap)Object.hasOwnProperty.call(this.keyMap,i)&&(t[i].initValue?this[i]=t[i].initValue:this[i]=!1);this.regControl()}regControl(){document.addEventListener("keydown",this.keyDown.bind(this)),document.addEventListener("keyup",this.keyUp.bind(this))}removeControl(){document.removeEventListener("keydown",this.keyDown.bind(this)),document.removeEventListener("keyup",this.keyUp.bind(this))}keyDown(t){t.preventDefault();for(const i in this.keyMap)if(Object.hasOwnProperty.call(this.keyMap,i)&&this.keyMap[i].keys.includes(t.key)){const t=this.keyMap[i].toggle,e=this.keyMap[i].initValue;t&&"down"===t?this[i]=!this[i]:t||(this[i]=void 0===e||!e)}}keyUp(t){for(const i in this.keyMap)if(Object.hasOwnProperty.call(this.keyMap,i)&&this.keyMap[i].keys.includes(t.key)){const t=this.keyMap[i].toggle,e=this.keyMap[i].initValue;t&&"up"===t?this[i]=!this[i]:t||(this[i]=void 0!==e&&e)}}loadKeyMap(t){this.keyMap=t}addItem(t,i,e=void 0,s=void 0){this.keyMap[t]={keys:i,toggle:e,initValue:s},this[t]=!1}removeItem(t){this.keyMap.hasOwnProperty(t)&&(delete this.keyMap[t],delete this.name)}}const d=n,p=class{constructor(t=null){this.mouseIsDown=!1,this.mouseX=0,this.mouseY=0,this.pmouseX=0,this.pmouseY=0,this.mouseButton=-1,this.mouseCX=0,this.mouseCY=0,this.pmouseCX=0,this.pmouseCY=0,this.regControl(t)}regControl(t){let i=t||document;this.targetElement=i,i.ownerDocument.addEventListener("mousedown",this.mouseDown.bind(this)),i.ownerDocument.addEventListener("mouseup",this.mouseUp.bind(this)),i.ownerDocument.addEventListener("mousemove",this.mouseMove.bind(this))}removeControl(){this.targetElement.ownerDocument.removeEventListener("mousedown",this.mouseDown.bind(this)),this.targetElement.ownerDocument.removeEventListener("mouseup",this.mouseUp.bind(this)),this.targetElement.ownerDocument.removeEventListener("mousemove",this.mouseMove.bind(this))}mouseDown(t){t.preventDefault(),this.mouseIsDown=!0,this.mouseButton=t.button}mouseMove(t){this.pmouseX=this.mouseX,this.pmouseY=this.mouseY,this.pmouseCX=this.mouseCX,this.pmouseCY=this.mouseCY,this.mouseX=t.offsetX,this.mouseY=t.offsetY,this.mouseCX=t.clientX,this.mouseCY=t.clientY}mouseUp(t){this.mouseIsDown=!1,this.mouseButton=-1}},f=class{constructor(t,i){this.camera=t,this.targetElement=i,this.pointerSpeed=.002,this.pointerLocked=!1,this.mouseIsDown=!1,this.mouseButton=-1,this.invertedX=!1,this.invertedY=!1,this.switchXY=!1,this.regControl()}regControl(){this.targetElement.ownerDocument.addEventListener("mousemove",this.mouseMove.bind(this)),this.targetElement.ownerDocument.addEventListener("pointerlockchange",this.pointerLockChange.bind(this)),this.targetElement.ownerDocument.addEventListener("pointerlockerror",this.pointerLockError.bind(this)),this.targetElement.ownerDocument.addEventListener("mouseup",this.mouseUp.bind(this)),this.targetElement.ownerDocument.addEventListener("mousedown",this.mouseDown.bind(this))}removeControl(){this.targetElement.ownerDocument.removeEventListener("mousemove",this.mouseMove.bind(this)),this.targetElement.ownerDocument.removeEventListener("pointerlockchange",this.pointerLockChange.bind(this)),this.targetElement.ownerDocument.removeEventListener("pointerlockerror",this.pointerLockError.bind(this)),this.targetElement.ownerDocument.removeEventListener("mouseup",this.mouseUp.bind(this)),this.targetElement.ownerDocument.removeEventListener("mousedown",this.mouseDown.bind(this))}lock(){this.targetElement.requestPointerLock()}unlock(){this.targetElement.ownerDocument.exitPointerLock()}setPointerSpeed(t){this.pointerSpeed=t}pointerLockChange(){this.targetElement.ownerDocument.pointerLockElement===this.targetElement?this.pointerLocked=!0:this.pointerLocked=!1}pointerLockError(){console.error("pointerLock unavailable")}mouseMove(t){if(!this.pointerLocked)return;const i=this.camera,e=t.movementX*(this.invertedX?1:-1),s=t.movementY*(this.invertedY?1:-1);i.rotate((this.switchXY?s:e)*this.pointerSpeed),i.tilt((this.switchXY?e:s)*this.pointerSpeed)}mouseDown(t){this.mouseIsDown=!0,this.mouseButton=t.button}mouseUp(t){this.mouseIsDown=!1}};function m(){let t=new Map;for(let i=0;i<arguments.length;i+=2){const e=arguments[i],s=arguments[i+1];t.set(e,s)}return t}function w(t,i,e=null,s=null,o=null){return{sky:t,ground:i,front:e,middle:s,back:o}}function y(t,i,e,s,h,r,a){return new o(t,i,e,s,h,r,a)}function u(t,i,s,o,h,r){return new e(t,i,s,o,h,r)}function c(t,i,e,s,o){return new l(t,i,e,s,o)}function M(t){return new d(t)}function O(t){return new p(t)}function g(t,i){return new f(t,i)}return i})()));